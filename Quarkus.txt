					Quarkus
//////////////////////////////////////////////////////////////////////////////////////////////
What is Quarkus?
  Quarkus is a framework to built on the top of Various java and JEE Standards.
  Quarkus has been designed to run on Multi platforms efficiently.
    -Bare Metal Machine
    -Containers
    -Cloud Native Env

    "A Kubernetes Native Java Stack tailored for OpenJDK ,Hotspot and GrallVM"


Quarkus:

 built on various standards. JEE , MicroProfile.


Java And JEE Standards:

Java Community Process , is non profitable organization who standardize and provides set of 
spec related java and jee technologies.

The JCP is the mechanism for developing standard technical specifications for Java technology


JCP offers Three Stands

1.JSE - Java Standard Edition
  -Java language Spec
  -Java VM Spec


2.JEE - Java Enterise Edition
 The Java Enterprise Edition offers APIs and tools for developing multitier enterprise applications.

 -Application Development Specs
    JPA Spec  - Vendor netural ORM Solutions
    JSON Binding - JSON-B  
    Java Servlet 
    JAX-RS - Building Resfull API
    JAX-WS - Building xml based webservices -SOAP Webservices
    Bean Validation
    JTA  - Java Transaction API
 -Container Specs 
    How to create Enterprise grade applications

3.JME - Java Micro Edition

Why JEE Spec failed In Modern Computing?
  
   JEE Spec was developed to build traditional Monolothic distributed,transactional, secure  Applications


What if i want to use JEE Spec for building Microservices?

 i cant use JEE Spec directly.

Birth of Project called MicroProfile

MicroProfile

Optimizing Enterprise Java - JEE for a Microservices Architecture.


Micro Profile addresses the need for enterprise java microservices.

It is set of secifications for handling microservices design patterns. 

MicroProfile enables JEE Developers to leverage their existing skill set while shifiting
their focus from traditional monolithic applications to Micro Services


MicroProfile is just collections of MicroServices Service Patterns on JEE standards


Implmentations:

1.Quarkus
etc...

MicroProfile Specs:

1.JAX-RS - To create HTTP based Microservices-
2.CDI - Context Dependency Injection - DI - Beans
3.JSON-B
4.Configuration
5.Falut
6.Health
etc....

Quarkus is built on top of various projects and standards


Quarkus Internal Architecture:

What is quarkus runtime?

How to run java apps?

 Java App
    |
  JVM
   |
  OS

Container:

 Java App
    |
  JVM
   |
 Linux
   |
 Docker Engine
   |
 os


Can we Run java apps without JVM ? Can We run java apps on native platforms?

 Java App
   |
  Linux

 Java App
   |
 Windows

 Java App
   |
  Mac

-Performance is higher. Why we need? because apps are running in cloud, we need less memory
and cpu power .

-Down time , apps are running in scalable , dynamic clusters of machines.

How to reduce boot time in containerisized env?

Container:

 Java App
    |
    |
  Linux
   |
 Docker Engine
   |
  os

s.o.p---jvm- java api--- c api--jni -----os api------|kern--dv---

javac ---byte code ----grallvm---convert this byte eq- native code at build time.

s.o.p ---os call
/////////////////////////////////////////////////////////////////////////////////////////////

Software Req:

1.GrallVm
............ 
2.jdk 11
3.maven/gradle
4.IntelliJ idea / vs code
5.Docker

/////////////////////////////////////////////////////////////////////////////////////////////

Quarkus : First App


how to use Maven as a build tool
how to create and scaffold a new project
how to deal with extensions
how to enable live reload
how to develop your application in your IDE
how to compile your application natively
how to setup Quarkus tools in Visual Studio Code, Eclipse IDE, Eclipse Che and IntelliJ


Project creations

Way -1

mvn io.quarkus:quarkus-maven-plugin:1.13.7.Final:create \
    -DprojectGroupId=my-groupId \
    -DprojectArtifactId=my-artifactId \
    -DprojectVersion=my-version \
    -DclassName="org.my.group.MyResource"


Way-2 
mvn io.quarkus:quarkus-maven-plugin:1.13.7.Final:create 


Way-3
https://code.quarkus.io/

Way -4 
 via Intellij idea plugins


////////////////////////////////////////////////////////////////////////////////////////////

Running Quarkus :

1.Dev
2.Test
3.Production

Dev:
 ./mvnw compile quarkus:dev - linux /mac

 mvnw compile quarkus:dev  - windows

 mvn compile quarkus:dev

Dev features;

-Live coding Reloading
   if write code and save and referesh your browser / any tool


How to build native image in quarkus

-Quarkus is not using GrallVM directly to build native image rather which uses mandral project
to convert Quarkus apps into native apps.

mvnw package -Pnative
    will convert current quarkus app into native binary.

how to package quarkus app/ fat jar /uber jar

./mvn clean package -DskipTests=true

$java -jar target/quarkus-app\quarkus-run.jar

////////////////////////////////////////////////////////////////////////////////////////////

Creating a linux executable without grallvm installed

 Via Docker , Podman(for linux only)

In windows:
   Docker file sharing settings must have been enabled.

 Way 1 : using command

mvnw package -Pnative  -Dquarkus.native.container-build=true  -Dquarkus.native.container-runtime=docker
   it will lookup in local machine whether docker is installed not 

 Way 2: using Docker file

 Steps:

  Your App -----Produce Native Image-----Executable---->Containerize it --->Container Image

 Once Image ready. You can lanuch

Steps:

Build Image:
docker build -f src/main/docker/Dockerfile.native -t quarkus-quickstart/getting-started .

Run it:
docker run -i --rm -p 8080:8080 quarkus-quickstart/getting-started

///////////

Native Image Can be built 

-Real Operating System using GrallVm setup

-From any operating System using Docker Container


&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Rest api Development

-JAX-RS Spec
  -RestEasy
-Servers
   Embeded Server
    -Netty

////////////////////////////////////////////////////////////////////////////////////////////////

JAX-RS :


Concepts :

1.Resource;

 It is class represents Restfull Resources.
@Path

                                  JAX-RS Implementation


Any one can implement Jax-RS spec.

1.RESTEasy
2.Jersy
etc...

RESTEasy
   FRAMWORK implements jax rs spec
RESTEasy is a JBoss / Red Hat project that provides various frameworks to help you build RESTful Web Services and RESTful Java applications.
It is an implementation of the Jakarta RESTful Web Services, an Eclipse Foundation specification that provides a Java API for RESTful Web Services over the HTTP protocol.
Moreover, RESTEasy also implements the MicroProfile REST Client specification API.


Lab : How to represent resources:
.................................

package org.ibm;

import javax.ws.rs.*;
import javax.ws.rs.core.MediaType;

@Path("/product")
public class ProductResource {

    @GET
    @Produces(MediaType.TEXT_PLAIN)
    public String findAll() {
        return "Product findAll";
    }

    @POST
    @Consumes(MediaType.TEXT_PLAIN)
    public void create(String product) {
        System.out.println(product);
    }

    @PUT
    @Consumes(MediaType.TEXT_PLAIN)
    public String update(String product) {
        return product + "Updated";
    }

    @DELETE
    public void remove() {
        System.out.println("Product deleted");
    }
}

Parameters:

@MatrixParam Extracts the value of a URI matrix parameter.
@QueryParam Extracts the value of a URI query parameter.
@PathParam Extracts the value of a URI template parameter.
@CookieParam Extracts the value of a cookie.
@HeaderParam Extracts the value of a header.
@Context Injects an instance of a supported resource

package org.ibm;

import javax.ws.rs.*;
import javax.ws.rs.core.MediaType;

@Path("/product")
public class ProductResource {

    @GET
    @Produces(MediaType.TEXT_PLAIN)
    public String findAll() {
        return "Product findAll";
    }

    @GET
    @Path("/{productId}")
    @Produces(MediaType.TEXT_PLAIN)
    public String getProductById(@PathParam("productId") String id) {
        return id;
    }

    // http://localhost:8080/product/filter?category=sports
    @GET
    @Produces(MediaType.TEXT_PLAIN)
    @Path("/filter")
    public String filterProductByCategoriees(@QueryParam("category") String category){
        System.out.println("");
        return category;
    }

    @POST
    @Consumes(MediaType.TEXT_PLAIN)
    public void create(String product) {
        System.out.println(product);
    }

    @PUT
    @Consumes(MediaType.TEXT_PLAIN)
    public String update(String product) {
        return product + "Updated";
    }

    @DELETE
    public void remove() {
        System.out.println("Product deleted");
    }
}

How to access "Servlelt like OBjects" inside Rest End Points

javax.ws.rs.core.HttpHeaders
javax.ws.rs.core.UriInfo
javax.ws.rs.core.Request
javax.servlet.http.HttpServletRequest
javax.servlet.http.HttpServletResponse
javax.servlet.ServletConfig
javax.servlet.ServletContext
javax.ws.rs.core.SecurityContext


package org.ibm;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.HttpHeaders;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.UriInfo;

@Path("/containerinfo")
public class ContainerResources {

    @Produces(MediaType.TEXT_PLAIN)
    @GET()
    @Path("/urls")
    public String getUriInfo(@Context UriInfo uriInfo) {
        System.out.println(uriInfo.getAbsolutePath() + " " + uriInfo.getRequestUri());
        return "Url Information";
    }

    @Produces(MediaType.TEXT_PLAIN)
    @GET()
    @Path("/headers")
    public String getHeaders(@Context HttpHeaders headers) {
        System.out.println(headers.getRequestHeaders());
        return "headers Information";
    }
}
////////////////////////////////////////////////////////////////////////////////////////////

Return Type of API:

 - String
 - Objects
 - Void
 - Response

Response;

 Object used to send "payload-data" along with meta data (http code,otherinformation)

HTTP Status codes:

-> informational response - 100 to 199
-> success response -  200-299
-> Redirects  - 300-399
-> client errors - 400-499
-> server errrors - 500-599

Response Builder:

 Response.ResponseBuilder is inner class of Response used to build response Objects.
  
Response  = payload  + meta data(headers,options)
            entity


package org.ibm;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.HttpHeaders;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.UriInfo;

@Path("/containerinfo")
public class ContainerResources {

    @Produces(MediaType.TEXT_PLAIN)
    @GET()
    @Path("/urls")
    public String getUriInfo(@Context UriInfo uriInfo) {
        System.out.println(uriInfo.getAbsolutePath() + " " + uriInfo.getRequestUri());
        return "Url Information";
    }

    @Produces(MediaType.TEXT_PLAIN)
    @GET()
    @Path("/headers")
    public String getHeaders(@Context HttpHeaders headers) {
        System.out.println(headers.getRequestHeaders());
        return "headers Information";
    }
}
//////////////////////////////////////////////////////////////////////////////////////////////

How to send JSON Response?

Quarks cant convert any object into JSON by default with help of "RestEasy" extension

 GET /developer/list: org.jboss.resteasy.core.NoMessageBodyWriterFoundFailure: Could not find MessageBodyWriter for response object of type: org.ibm.entity.Developer of media type: application/json

Why because we are missing serilizer and desserializer - JSON Converter not there.
  

Dealing with extensions	:
 
Extensions are libs. which can be added dynamically when you develop app


./mvnw quarkus:list-extensions

  To list available supported extsions.

./mvnw quarkus:add-extension -Dextensions="resteasy-jsonb"

Eg for RestEasy Extensions:

RESTEasy Jackson                                   quarkus-resteasy-jackson
RESTEasy JAXB                                      quarkus-resteasy-jaxb
RESTEasy JSON-B                                    quarkus-resteasy-jsonb
RESTEasy Multipart                                 quarkus-resteasy-multipart
RESTEasy Mutiny                                    quarkus-resteasy-mutiny
RESTEasy Qute                                      quarkus-resteasy-qute
RESTEasy Reactive Jackson                          quarkus-resteasy-reactive-jackson
RESTEasy Reactive JSON-B                           quarkus-resteasy-reactive-jsonb
RESTEasy Reactive Qute                             quarkus-resteasy-reactive-qute
RESTEasy Reactive                                  quarkus-resteasy-reactive
RESTEasy JAX-RS                                    quarkus-resteasy


package org.ibm;

import org.ibm.entity.Developer;

import javax.ws.rs.*;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.UriBuilder;

@Path("/developer")
public class DeveloperResource {

    @POST
    @Path("/create")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    public Response createDeveloper(Developer developer) {
        developer.persist();
        System.out.println(developer);
        ///developer/1 = UriBuilder.fromResource().
        return Response.created(UriBuilder.fromResource(DeveloperResource.class).path("/create/" + Long.toString(developer.getId())).build())
                .entity(developer)
                .header("dev", developer.getName())
                .build();
    }

    @Path("/list")
    @GET
    @Produces(MediaType.APPLICATION_JSON)
    public Response getDeveloper() {
        Developer developer = new Developer();
        developer.setName("Subramanian");
        developer.persist();
        return Response.ok().entity(developer).build();
    }

}

//////////////////////////////////////////////////////////////////////////////////////

How handle Exceptions, How to send error Responses


package org.ibm;

import javax.ws.rs.*;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import javax.ws.rs.ext.ExceptionMapper;
import javax.ws.rs.ext.Provider;

@Path("/customer")
public class CustomerResource {

    @GET
    @Path("/{customerId}")
    @Produces(MediaType.TEXT_PLAIN)
    public Response getCustomerId(@PathParam("customerId") String id) {

        if (id.equals("abc")) {
            throw new WebApplicationException("Element with position " + id + " does not exist.", 404);
        }
        //biz if this failed throw new YourBizException("Something went wrong in my biz")
        return Response.ok(Integer.parseInt(id)).build();
    }

    @Provider
    public static class WebApplicationErrors implements ExceptionMapper<WebApplicationException> {
        @Override
        public Response toResponse(WebApplicationException e) {
            //return Response.status(500).entity(e.getMessage()).build();
            return Response.status(Response.Status.BAD_GATEWAY).entity(e.getMessage()).header("err", "myerr").build();
        }
    }

    @Provider
    public static class CustomerExceptionMapper implements ExceptionMapper<Exception> {
        @Override
        public Response toResponse(Exception e) {
            //return Response.status(500).entity(e.getMessage()).build();
            return Response.status(Response.Status.BAD_GATEWAY).entity(e.getMessage()).header("err", "myerr").build();
        }
    }

}

}
////////////////////////////////////////////////////////////////////////////////////////////

Configuration:
.............
- How to configure a Quarkus service
- How to inject configuration parameters in the service
- How to apply values depending on the environment
- How to correctly configure the logging system
- How to create customizations for the configuration system


configuration has been implemented using MicroProfile config 2.0 spec
 https://github.com/eclipse/microprofile-config/releases/tag/2.0

configuration naming conventions:
.................................
This is similar to Java package namespacing.
because java packages are unquie

resources/application.properties

com.acme.myproject.someserver.url = http://some.server/some/endpoint
com.acme.myproject.someserver.port = 9085
com.acme.myproject.someserver.active = true
com.acme.other.stuff.name = Karl
com.acme.myproject.notify.onerror=karl@mycompany,sue@mcompany
some.library.own.config=some value

application.properties

How to supply configuration parameters to the application.

Syntax:

domain.message=value



application.properties

#Your App configuration
greeting.message = Hai
greeting.name = Subramanian
greeting.from = quarkus

package org.ibm;

import org.eclipse.microprofile.config.inject.ConfigProperty;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.core.Response;

@Path("/config")
public class ConfigResource {

    //inject configuration values
    @ConfigProperty(name = "greeting.message")
    String message;
    @ConfigProperty(name = "greeting.name")
    String name;
    @ConfigProperty(name = "greeting.from")
    String from;
    @ConfigProperty(name = "greeting.suffix", defaultValue = "!")
    String suffix;

    @Path("/greet")
    @GET
    public Response getGreeting() {
        return Response.ok().entity(message + name + "from " + from + " " + suffix ).build();
    }
}


Does Quarkus Supports Yaml Formats ?

Yes
./mvnw quarkus:add-extension -Dextensions="config-yaml"

You can mix both files

application.yml

greeting:
  message: Hello Yaml


package org.ibm;

import org.eclipse.microprofile.config.inject.ConfigProperty;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.core.Response;

@Path("/config")
public class ConfigResource {

    //inject configuration values
    @ConfigProperty(name = "greeting.message")
    String message;
    @ConfigProperty(name = "greeting.name")
    String name;
    @ConfigProperty(name = "greeting.from")
    String from;
    @ConfigProperty(name = "greeting.suffix", defaultValue = "!")
    String suffix;

    @Path("/greet")
    @GET
    public Response getGreeting() {
        return Response.ok().entity(message + name + "from " + from + " " + suffix ).build();
    }
}


# Accessing Configuration Properties Programmatically

You want to access configuration properties programmatically instead of injecting
them using the org.eclipse.microprofile.config.inject.ConfigProperty
annotation.


Inject the org.eclipse.microprofile.config.Config class in the object for which
you want to access properties programmatically.

The Eclipse MicroProfile Configuration spec allows you to inject org.eclipse.micro
profile.config.Config to get properties programmatically instead of injecting
directly with ConfigProperty.

After dicussion with CDI



# Overwriting Configuration Values Externally

You want to overwrite any configuration value at runtime.

Quarkus lets you overwrite any configuration property by setting a configuration
as a system property (-Dproperty.name=value) and/or as an environment variable
(export PROPERTY_NAME=value). 


System properties have more priority than environment
variables.


./mvnw clean package -DskipTests


>java -Dgreeting.message=Aloha -Dgreeting.name=John -jar target/quarkus-app/quarkus-run.jar


# Configuring with Profiles

You want to overwrite configuration values depending on the environment in which
you are running Quarkus.

Quarkus supports the notion of configuration profiles.

These allow you to have multiple configuration values for the same property in the same file and enable different values to suit the environment in which you are running the service.


The syntax for configuration profiles is %{profile}.config.key=value.

Types of built-in profiles

dev
test
prod

Open src/main/resources/application.properties file and set to start Quarkus at port
8181 in development mode:

%dev.quarkus.http.port=8181


./mvnw compile quarkus:dev

/////////////////////////////////////////////////////////////////////////////////////////////

                                                                 Property Sources
   Your App
   application.properties                                      1.application.properties | Yaml
     foo.myvalue=bar
                                                               2. Env variables                
							       3. command line args 
    @ConfigProperty(name="foo.somepro",defaultValue="") |->    4. External servers
    myVariable                                          |


/////////////////////////////////////////////////////////////////////////////////////////////

Types of COnfiguration:

1.Application information configurations
   if you want to supply application spefic congfig
   messages, names, etc......

2.Application infrastructure configurations
 
   HTTP server configurations.

   Data Source Configurations

   ORM Configurations -Hibernate

   etc.....

All infra config starts with

 quarkus.
https://quarkus.io/guides/all-config
 
..............................................................................................
                                       Thread Management

NonBlocking:

 Quarkus Http Engine is non blocking.

How traditional Web Servers working?


Blocking IO:

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class CopyBytes {
    public static void main(String[] args) throws IOException {

        FileInputStream in = null;
        FileOutputStream out = null;

        try {
            in = new FileInputStream("xanadu.txt");
            out = new FileOutputStream("outagain.txt");
            int c;

            while ((c = in.read()) != -1) {
                out.write(c);
            }
        } finally {
            if (in != null) {
                in.close();
            }
            if (out != null) {
                out.close();
            }
        }
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////


.class           JNI(c layer)           Linux OS            Kernal
in.read()-------->read()----sys call(c) read() ------>   File Descriptor    DD
                                                           read : ### ------|-----|DEVICE

FD :
 MAP

Key - value
0   - Keyboard         resoucers
1   - Monitor
2   - Monitor
................

Kernal

for(;;){
   iterate fd
   0 -key ----- checks any data
   1 - m --- ----- checks any data
   2 - m --- ----- checks any data
   3 - networksocket --- ----- checks any data
   4 -networksocket --- ----- checks any data  - yes- copy data into buffer|---OK(EVENT)----|Inform---User Space----|ApplicationRuntime----process data.
   5 -filesystem----- ----- checks any data
}

Event loop is a infinte for loop keep on spins for watching any one of the file descriptor for 
"data".


Quarkus uses Vertx Event loop architecture for handling non blocking HTTP Server handling processing:

Every req in Quarkus is delegated to Vert.x event loop thread.

Vert.x uses more threads , generally per cpu core - 2 threads :  if 12 cores, 24 threads

/////////////////////////////////////////////////////////////////////////////////////////////

Context Depedency Injection: CDI
.................................

CDI Services:

Contexts: The ability to bind the lifecycle and interactions of stateful components(bean) to well-defined but extensible lifecycle contexts

Dependency injection: The ability to inject components(bean) into an application in a typesafe way, including the ability to choose at deployment time which implementation of a particular interface to inject

How to Inject bean(component?

@Inject

Scopes Of beans:

Request @RequestScoped
  A user’s interaction with a web application in a single HTTP request.

Session @SessionScoped
A user’s interaction with a web application across multiple HTTP requests.

Application @ApplicationScoped
    Shared state across all users’ interactions with a web application.

Dependent @Dependent

The default scope if none is specified; it means that an object exists to serve exactly one client (bean) and has the same lifecycle as that client (bean).


@SingleTon
   Only one instance per container


@ApplicationScoped vs @SingleTon:

SingleTon beans are eagerly created.
ApplicationScoped is lazyly created
///////////////////////////////////////////////////////////////////////////////////////////


package org.ibm.services;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import javax.enterprise.context.ApplicationScoped;
import javax.inject.Inject;
import java.awt.*;

@ApplicationScoped
public class GreeterService {

    @Inject
    HelloService helloService;

    private HaiService haiService;

    public GreeterService(){

    }

    @Inject
    public GreeterService(HaiService haiService){
        this.haiService = haiService;
    }
    //new GreeterService(new HaiService())

    @PostConstruct
    public void init() {
        System.out.println("GreeterService is init");
    }

    public String sayHello() {
        return helloService.sayHello()  + haiService.sayHai();
    }

    @PreDestroy
    public void destroy() {
        System.out.println("Greeter Service destroy is called");
    }
}


package org.ibm.services;

import javax.enterprise.context.ApplicationScoped;

@ApplicationScoped
public class HaiService {

    public String sayHai(){
       return "Hai";
    }
}

package org.ibm.services;

import javax.enterprise.context.ApplicationScoped;
import javax.inject.Singleton;

//@ApplicationScoped
@Singleton
public class HelloService {
    public String sayHello() {
        return "Hello Service!!!";
    }
}
package org.ibm;

import org.ibm.services.GreeterService;

import javax.annotation.PostConstruct;
import javax.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;

@Path("/hello")
public class GreetingResource {

    @Inject
    GreeterService greeterService;
    @GET
    @Produces(MediaType.TEXT_PLAIN)
    public String hello() {
        return greeterService.sayHello();
    }
}
////////////////////////////////////////////////////////////////////////////////////////////
                                   Data Sources
////////////////////////////////////////////////////////////////////////////////////////////

How to configure Datasources:

In order to connect database.

JDBC AND ORM:
............
if you want to connect database

1.drivers
2.connection information
3.get Connection Object
4.start writing

Data Modules supported by Quarkus:
...................................

1.Core Data source

2.Hibernate and data source

3.Hibernate and Panache


Data source configuration:

application.properties

quarkus.datasource.db-kind=postgresql 
quarkus.datasource.username=<your username>
quarkus.datasource.password=<your password>

quarkus.datasource.jdbc.url=jdbc:postgresql://localhost:5432/hibernate_orm_test
quarkus.datasource.jdbc.max-size=16



Default Data Source: having minmum configuration: H2
quarkus.datasource.db-kind=h2

db-kind 
  Property says what type of database we connect.

common db-kind value conventions

DB2: db2

Derby: derby

H2: h2

MariaDB: mariadb

Microsoft SQL Server: mssql

MySQL: mysql

Oracle: oracle

PostgreSQL: postgresql, pgsql or pg

////////////////////////////////////////////////////////////////////////////////////////////

Required Dependency:

1./mvnw quarkus:add-extension -Dextensions="agroal"

2.relational database driver.

mvnw quarkus:add-extension -Dextensions="jdbc-postgresql"

mvnw quarkus:add-extension -Dextensions="jdbc-h2"


JDBC Code using Datasource:

application.properties


#Datasource configuration.
quarkus.datasource.db-kind=h2


package org.ibm.services;

import io.agroal.api.AgroalDataSource;

import javax.annotation.PostConstruct;
import javax.enterprise.context.ApplicationScoped;
import javax.inject.Inject;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

@ApplicationScoped
public class UserService {

    @Inject
    AgroalDataSource defaultDataSource;

    @PostConstruct
    public void init() {
        System.out.println("H2- db init is called");
        try {
            Connection connection = defaultDataSource.getConnection();
            System.out.println(connection);
            Statement stmt = connection.createStatement();
            stmt.executeUpdate("CREATE TABLE TABLE1(id INT NOT NULL,  title VARCHAR(50))");
            stmt.executeUpdate("INSERT INTO TABLE1 " + "VALUES (100, 'Subramanian')");
            ResultSet rs = stmt.executeQuery("select * from table1");
            while (rs.next()) {
                System.out.println(rs.getInt(1) + "  " + rs.getString(2));
            }
            stmt.close();
            connection.close();

        } catch (SQLException sqlException) {
            System.out.println(sqlException.getMessage());
        }
    }
    public String getUser(){
        return  "User";
    }
}

Multiple Datasources
  
 We can have multiple datasources, each data source can connect different type of databses

Rule : Data base Per service Rule of Microservice

i want to configure three data source

1.default
2.users
3.inventory


quarkus.datasource.domainname.db-propertie=value

application.properties

quarkus.datasource.db-kind=h2
quarkus.datasource.username=username-default
quarkus.datasource.jdbc.url=jdbc:h2:tcp://localhost/mem:default
quarkus.datasource.jdbc.max-size=13

quarkus.datasource.users.db-kind=h2
quarkus.datasource.users.username=username1
quarkus.datasource.users.jdbc.url=jdbc:h2:tcp://localhost/mem:users
quarkus.datasource.users.jdbc.max-size=11

quarkus.datasource.inventory.db-kind=h2
quarkus.datasource.inventory.username=username2
quarkus.datasource.inventory.jdbc.url=jdbc:h2:tcp://localhost/mem:inventory
quarkus.datasource.inventory.jdbc.max-size=12


package org.ibm.services;

import io.agroal.api.AgroalDataSource;
import io.quarkus.agroal.DataSource;
import javax.annotation.PostConstruct;
import javax.enterprise.context.ApplicationScoped;
import javax.inject.Inject;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

@ApplicationScoped
public class UserService {

    @Inject
    AgroalDataSource defaultDataSource;

    @Inject
    @DataSource("users")
    AgroalDataSource usersDataSource;

    @PostConstruct
    public void init() {
        System.out.println("H2- db init is called");
        try {
            Connection connection = defaultDataSource.getConnection();
            System.out.println(connection);
            Statement stmt = connection.createStatement();
            stmt.executeUpdate("CREATE TABLE TABLE1(id INT NOT NULL,  title VARCHAR(50))");
            stmt.executeUpdate("INSERT INTO TABLE1 " + "VALUES (100, 'Subramanian')");
            ResultSet rs = stmt.executeQuery("select * from table1");
            while (rs.next()) {
                System.out.println(rs.getInt(1) + "  " + rs.getString(2));
            }
            stmt.close();
            connection.close();

        } catch (SQLException sqlException) {
            System.out.println(sqlException.getMessage());
        }
    }
    public String getUser(){
        try {
            Connection connection = usersDataSource.getConnection();
            System.out.println(connection);
            Statement stmt = connection.createStatement();
            stmt.executeUpdate("CREATE TABLE user(id INT NOT NULL,  title VARCHAR(50))");
            stmt.executeUpdate("INSERT INTO user " + "VALUES (100, 'Subramanian')");
            ResultSet rs = stmt.executeQuery("select * from user");
            while (rs.next()) {
                System.out.println(rs.getInt(1) + "  " + rs.getString(2));
            }
            stmt.close();
            connection.close();

        } catch (SQLException sqlException) {
            System.out.println(sqlException.getMessage());
        }
        return  "User";
    }
}
////////////////////////////////////////////////////////////////////////////////////////////

Hibernate ORM - JPA -Panache:
.............................

Quarkus can integrate ORM Via JPA Spec ,provider is Hibernate.

Configuration:

1.application.properties

2.@Entity

Dependency:

1.Hibernate 
io.quarkus:quarkus-hibernate-orm
2.JDBC Driver
 jdbc-h2 ,jdbc-db2

application.properties

# datasource configuration
quarkus.datasource.db-kind = postgresql
quarkus.datasource.username = hibernate
quarkus.datasource.password = hibernate
quarkus.datasource.jdbc.url = jdbc:postgresql://localhost:5432/hibernate_db

# drop and create the database at startup (use `update` to only update the schema)
quarkus.hibernate-orm.database.generation=drop-and-create

/////////////////////////////////////////////////////////////////////////////////////////////

Hibernate:

 -CURD operations
 -Caching - You can use hibernate in memory caching, caching providers  (memcache,redis,inifispan)
 -Transaction Management -JTA -narayana-jta ---| Reactive + Non Reactive Style


Example:

Steps:

1.start db server
docker run --ulimit memlock=-1:-1 -it --rm=true --memory-swappiness=0 --name quarkus_test -e POSTGRES_USER=quarkus_test -e POSTGRES_PASSWORD=quarkus_test -e POSTGRES_DB=quarkus_test -p 5432:5432 postgres:11.5

////////////////////////////////////////////////////////////////////////////////////////////

SIMPLIFIED HIBERNATE ORM WITH PANACHE:
......................................

In General, curd is implemented using

JPA and Hibernate specific apis, this is makes our code tightly coupled.

DAO Design pattern abstracts away how to handle database operations like DOMAIN Models.

Quarkus offers that abstraction via panache.

@Entity
public class Person extends PanacheEntity {
    public String name;
    public LocalDate birth;
    public Status status;

    public static Person findByName(String name){
        return find("name", name).firstResult();
    }

    public static List<Person> findAlive(){
        return list("status", Status.Alive);
    }

    public static void deleteStefs(){
        delete("name", "Stef");
    }
}


PanacheEntity Features:
///////////////////////

1.offers most of the biz apis -  finder apis,delete,update,persit......
2.you can extend /add your own biz apis as you need.
3.can return Data
    1.directly - eg if you are asking list of customers -List will be returned
    2.Stream of data - you can use java 8 stream style apis.
       findAll().sort().distinct().toList().....


Hibernate/ORM Design patterns:

1. active record pattern
 
Enity will have
  -Data 
  -api to manipulate data
In Quarkus , if you want to implement this Pattern, you can use PancheEntity as base class

@Entity
public class Person extends PanacheEntity {
    public String name;
    public LocalDate birth;
    public Status status;

    public static Person findByName(String name){
        return find("name", name).firstResult();
    }

    public static List<Person> findAlive(){
        return list("status", Status.Alive);
    }

    public static void deleteStefs(){
        delete("name", "Stef");
    }
}


2. Repository Design pattern

  -Data will isloated into entities
  -apis to manipulate that data will be isloated

@ApplicationScoped
public class PersonRepository implements PanacheRepository<Person> {

   // put your custom logic here as instance methods

   public Person findByName(String name){
       return find("name", name).firstResult();
   }

   public List<Person> findAlive(){
       return list("status", Status.Alive);
   }

   public void deleteStefs(){
       delete("name", "Stef");
  }
}
/////////////////////////////////////////////////////////////////////////////////////////////
                                     Logging
/////////////////////////////////////////////////////////////////////////////////////////////

You want to change the default logging configuration.

Open src/main/resources/application.properties and add the following content:

quarkus.log.level=DEBUG

# Changing Logger Configuration

You want to change the default logging configuration.

Open src/main/resources/application.properties and add the following content:
quarkus.log.level=DEBUG


You can also enable storing logs in a file by using quarkus.log.file.enable property.
The output is written by default to a file named quarkus.log:
quarkus.log.file.enable=true


Application Logging:
.......................

Most of the time, your applications need to write their own logging messages and not
rely solely on the default logs provided by Quarkus. Applications may use any of the
supported APIs for logging, and the logs will be merged.

Quarkus supports these logging libraries:

• JDK java.util.logging
• JBoss logging
• SLF4J
• Apache Commons Logging

package org.acme;

import org.jboss.logging.Logger;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;

@Path("/hello-resteasy")
public class GreetingResource {
    private static Logger logger = Logger.getLogger(GreetingResource.class);

    @GET
    @Produces(MediaType.TEXT_PLAIN)

    public String hello() {
        logger.info("Hello is called");
        return "Hello RESTEasy";
    }
}
///////////////////////////////////////////////////////////////////////////////////////////

Logging Reporting Technology: Centeralized Log Management Micro Service Log Management.
.......................................................................................


When working with microservice architectures and Kubernetes, logging is an important
thing to take into consideration because each service is logging individually; but
as a developer or operator, you might want to have all the logs centralized in one
place so they can be consumed as a whole.



Use the GELF extension to produce logs in GELF format and send them using either
TCP or UDP.

Graylog extended log format (GELF) is understood by three of the most centralized
logs systems that are used nowadays:


• Graylog (MongoDB, Elasticsearch, Graylog)
 -Product to collect logs from the application(ms) for analysis.

• ELK (Elasticsearch, Logstash, Kibana)

• EFK (Elasticsearch, Fluentd, Kibana)


Steps:

1.mvnw quarkus:add-extension -Dextensions="logging-gelf"

2.application.properties

quarkus.log.handler.gelf.enabled=true
quarkus.log.handler.gelf.host=localhost
quarkus.log.handler.gelf.port=12201

3.code
package org.acme;

import org.jboss.logging.Logger;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;

@Path("/hello-resteasy")
public class GreetingResource {
    private static Logger logger = Logger.getLogger(GreetingResource.class);

    @GET
    @Produces(MediaType.TEXT_PLAIN)

    public String hello() {
        logger.info("Hello is called");
        return "Hello RESTEasy";
    }
}

4.Send logs to Graylog
To send logs to Graylog, you first need to launch the components that compose the Graylog stack:
MongoDB
Elasticsearch
Graylog


5.create dockercompose and start running 

src/resources/docker-compose.yml
version: '3.2'

services:
  elasticsearch:
    image: docker.elastic.co/elasticsearch/elasticsearch-oss:6.8.2
    ports:
      - "9200:9200"
    environment:
      ES_JAVA_OPTS: "-Xms512m -Xmx512m"
    networks:
      - graylog

  mongo:
    image: mongo:4.0
    networks:
      - graylog

  graylog:
    image: graylog/graylog:3.1
    ports:
      - "9000:9000"
      - "12201:12201/udp"
      - "1514:1514"
    environment:
      GRAYLOG_HTTP_EXTERNAL_URI: "http://127.0.0.1:9000/"
    networks:
      - graylog
    depends_on:
      - elasticsearch
      - mongo

networks:
  graylog:
    driver: bridge

6. start containers 

 src/resources/docker-compose up



7.Configuration in graylog 


login using http://localhost:9000
 : using admin and admin

 Then, you need to create a UDP input in Graylog.
    You can do it from the Graylog web console (System → Input → Select GELF UDP) available at 
  
where need to select - global input.




NOte : Build your app in production mode , then only logs will be emitted

./ mvnw package

java -jar target/quarkus-app/quarkus-run.jar


8.send messages watch the messages in graylog dashboard


//////////////////////////////////////////////////////////////////////////////////////////////

				   Reactive Programming
//////////////////////////////////////////////////////////////////////////////////////////////

What is reactive programming?


It is one of the  Programming Paradigm(way).

Reactive programming is collection of many programming paradigm best parts and principles.

Reactive programming is collection of oo , functional, event driven......principles


Reactive Programming languages:
..............................

There is no such separate pl which adopts reactive programming alone.
 rather which is eXtended by other languages : 
Reactive programming is just like plugin, which has been pluged in inside languages via libs and frameworks.

Reactive-X(x means Extension /plugin)

C# can extend Reactive programming principles -Rx.net /RXC#
js  - rxjs
//////////////////////////////////////////////////////////////////////////////////////////
                             Java and Reactive Programming
    ....................................................................................


RxJava
Project Reactor
Mutiny - SmallRye Product.
java 9 Reactive Stream Api


                                      Reactive Programming 
//////////////////////////////////////////////////////////////////////////////////////////////

What is reactive programming?

It is one of the  Programming Paradigm(way).

Reactive programming is collection of many programming paradigm best parts and principles.

Reactive programming is collection of oo , functional, event driven......principles


Reactive Programming languages:
..............................

There is no such separate pl which adopts reactive programming alone.
 rather which is eXtended by other languages : 
Reactive programming is just like plugin, which has been pluged in inside languages via libs and frameworks.

Reactive-X(x means Extension /plugin)

C# can extend Reactive programming principles -Rx.net
Java even  - Rxjava
js  - rxjs
///////////////////////////////////////////////////////////////////////////////////////////

History of Rx Programming:
.........................

At Microsoft Erik Meijer who created Reactive Programming ideas from "C#".

Core Ideas behind Reactive Programming :

Object:
  -setters - write
  -getters - read

getters
   -single value - scallar values -number,strings,booleans,object
   -iteralble value(many values) - array , collection-list,map,set

Iterations:
 IEnumerable ,IEnumerator 

IEnumerator 
   - bridge interface which is used to iterate collection

  producer                                  consumer/subscriber Caller(requester)
  moveNext():boolean --------------------  give me a value /error

Based this we define programming model called "Pull based"

 consumer pulls value from producer.
 consumer has control over producer.
 consumer only decide when he wants item.

             "Values are produced on demand by consumer"

Before a decade, programming model started like "Cloud based, async programming Programming"

Push Based Programming:


public List<Cutomer> findAll(){

   return customerList;
}


public void findAll(Consumer dataconsumer,Consumer errorConsumer,Consumer cmp){

   ....talk to db
   once data ready
   consumer.call(customers) //emit event 
   dataconsumer.dispatch("dataready",customers)
   errorConsumer.dispatch("error",errorObject)
   cmp.dispatch("completed")  
}

int status = update(); -----|block
List cust = findAll(); ----|block
Customer cus = select();

callback/event driven 

findAll(customers->sop(customers),err->sop(err),done->sou )

////////////////////////////////////////////////////////////////////////////////////////////

An Observable is the asynchronous/push “dual” to the synchronous/pull Iterable

event	        Iterable (pull)	 Observable (push)
retrieve data	T next()	 onNext(T)
discover error	throws Exception onError(Exception)
complete	!hasNext()	 onCompleted()
///////////////////////////////////////////////////////////////////////////////////////////

Reactive Programming Standards:
................................

1.The Reactive Manifesto
   -Message Driven
   -Responsive
   -Resilient
   -Elastic

2.Reactive Streams

  -Spec invented  to fix problems in "Push Based Programming"

Back Pressure:

   Publisher is fast to produce data where consumer/operator is too slow to handle /process
data , that time "back pressure is created". when back press is created , you might loose 
data. This is what the problem of push based programming



   UpStream/source stream is fast to produce data where consumer/down stream is too slow to handle /process data , that time "back pressure is created". when back press is created , you might loose data. This is what the problem of push based programming.

 "Reactive Streams"  talks about how consumer/down stream can request upstream/source to stop
 sending data before it completes.

  Reactive Stream = Push + Pull => React Push =>Reactive Streams


Rxjava :

 1.Observable- type to represent Producer/Publisher
 2.Flowable  - Same Observable(Producer) 

 Observable has not implemented Reactive Stream spec
 Flowable has implemented React Stream Spec.


Project Reactor

 Mono /Flux implements Reactive stream spec

Mutiny
  Multi implements Reactive Stream spec

                                      org.reactivestreams.Publisher
						    |
			           -----------------------------------------
                                         |           |             |
                                      Flowable     Mono/Flux      Multi


//////////////////////////////////////////////////////////////////////////////////////////

Mutiny:
......

Mutiny is reactive lib built on react stream spec.

Features:

Event-Driven
Navigable
Non-Blocking I/O
Quarkus and Vert.x native
Made for an asynchronous world
Reactive Converters Built-In


Rxfication:
  Wrapping core rx libs inside other libs

eg:
   Spring WebFlux ---- rxfied on project Reactor
   Vertx.Rx   ------> rxified on Vert.x
   Angular -----> rxified on rxjs
   quakurs-muntiny -  rxified on quarkus


Mutiny Types(Publisher):
........................

  
1.Uni
2.Multi


Uni:  
 A Uni represents a stream that can only emit either "an" item or "a" failure event.
Only one either data or error

Multi
A Multi represents a stream of data.

A stream can emit 0, 1, n, or an infinite number of items.
 0 to infinte.

A Multi<T> is a data stream that:

1.emits 0..n item events

2.emits a failure event

3.emits a completion event for bounded streams

Uni/Multi Object Creation:

1.Can be created using factory pattern.

  Uni.create()

2.All operators(methods) are chainable - Pure function patterns

3.The out put of one operator will be input to the next operator in functional way
  The ouput always immutable. when any operations happens on data , will not have 
  old data.
  Each operator will have fresh data always.

4.Uni/Multi is Generic Powered .you can emit any type of data.

5.Events are represented like
  
   on+EventName eg : onItem, onError onComplete

6.Muntiny Streams are lazy
    "Dont emit data until you subscribe".

////////////////////////////////////////////////////////////////////////////////////////////

I(Publisher) have item, that need to be delivered to Subscriber with delay of 1ms

  Delay implementation
    -Timer
    -Thread
    -Custom Logic

Imperative  code vs Declarative code.

Imperative says that how to do(logic) and also what to do(requriement)

Declarative programming says that dont focus logic(how to do) , focus what to do(requirement).
today lot of programming languages offers declarative apis via lib or as part of language.

eg: Java streams 
     -Declarative Collection api for processing data.
      List.toStream().sort().distinct().forEach

Reactive apis / operators are highly declarative


package com.ibm.reative;

import io.smallrye.mutiny.Uni;

public class FirstMutiny {
    public static void main(String[] args) {
        //Uni
        String dataSource ="Hello Muntiny";
        Uni.createFrom()
                .item(dataSource) //data source
                .onItem().transform(item -> item) //trigger event - data event //up stream
                .onItem().transform(item->item.toUpperCase())  // down stream
                .subscribe().with(data -> System.out.println(data), err -> System.out.println(err));
    }
}


package com.ibm.reative;

import io.smallrye.mutiny.Uni;

import java.time.Duration;


public class UniDelay {
    public static void main(String[] args) {
        System.out.println("start");
        Uni.createFrom().item(1)
                .onItem().transform(i -> "hello-" + i)
                .onItem().delayIt().by(Duration.ofMillis(1000))
                .subscribe().with(System.out::println);
        System.out.println("end");
    }
}

package com.ibm.reative;

import io.smallrye.mutiny.Uni;

import java.time.Duration;

public class UniErrors {

    public static String fallback() {
        return "data from caching server";
    }

    public static String mybizlogic() {
        String something = "I have data";
        boolean foundError = true;
        if (foundError) {
            System.out.println("method is called in error state");
             throw new RuntimeException("Boom");
        }
        return something;
    }

    public static void main(String[] args) {
        Uni.createFrom()
                .item(UniErrors::mybizlogic)
                .onItem().transform(d -> d.toUpperCase())
                .onItem().transform(d -> d.replace(" ", "--"))
                .onFailure().retry().atMost(4)
                .onFailure().recoverWithItem(UniErrors::fallback)
                .subscribe().with((item) -> System.out.println(item), err -> System.out.println(err.getMessage()));

    }
}
/////////////////////////////////////////////////////////////////////////////////////////////

Quarkus And Muntiny:

Quarkus and Muntiny helps to build async reactive microservices.


A quick glance at the Quarkus engine and how it enables reactive

A brief introduction to Mutiny - the reactive programming library used by Quarkus

The difference between RESTEasy, RESTEasy Reactive and Reactive Routes

The bootstrap of a reactive application using RESTEasy Reactive

Creating a reactive JAX-RS endpoint (asynchronous, streams…​)

Using reactive database access

Interacting with other reactive APIs

///////////////////////////////////////////////////////////////////////////////////////////////

Quarkus Application code:

1.Non Blocking code which runs on vertx engine : Event loop threads
2.Blocking code is running Vertx engine on special threads "Worker pool threads".

In Quarkus world

1.declarative code is running event loop thread
2.imperative code  is running on work loop thread


How to start working with Reactive Quarkus?

YOu need to add Reactive extension libs

quarkus-resteasy-reactive


//////////////////////////////////////////////////////////////////////////////////////////


Web Routing:

1.JAX-RS - RESTEASY Implementation

2.Vert.x  -  functional style.


3.Mixing Vertx and Quarkus style

  -annotation style
  -pure functional style


import javax.enterprise.context.ApplicationScoped;
import javax.enterprise.event.Observes;

import io.vertx.ext.web.Router;

@ApplicationScoped
public class MyRouteRegistar {

    public void init(@Observes Router router) {
        router.get("/my-route").handler(rc -> rc.response().end("Hello from my route"));
    }

}
 

Declarative:
package org.acme.reactive.routes;

import javax.enterprise.context.ApplicationScoped;

import io.quarkus.vertx.web.Route;
import io.vertx.core.http.HttpMethod;
import io.vertx.ext.web.RoutingContext;

@ApplicationScoped
public class MyDeclarativeRoutes {

    @Route(path = "/", methods = HttpMethod.GET)
    public void handle(RoutingContext rc) {
        rc.response().end("hello");
    }

    @Route(path = "/hello", methods = HttpMethod.GET)
    public void greetings(RoutingContext rc) {
        String name = rc.request().getParam("name");
        if (name == null) {
            name = "world";
        }
        rc.response().end("hello " + name);
    }
}

//////////////////////////////////////////////////////////////////////////////////////////

Micro services Management patterns and relience patterns
  -SmallRye Implementations

Quarkus implements SmallyRye projects for implementing "MicroProfile Microservices spec"


1.Loggers

2.Fault Management

3.Health

4.Open Tracing

5.Micro Meter

//////////////////////////////////////////////////////////////////////////////////////////

Falut Tolerance:

  Something went wrong inside application, how to handle it an how to react it.



SmallRye Fault Tolerance

An implementation of MicroProfile Fault Tolerance




Fault Tolerance provides developers with the following strategies for dealing with failure:

Timeout: Define a maximum duration for execution

Retry: Attempt execution again if it fails

Bulkhead: Limit concurrent execution so that failures in that area can’t overload the whole system

CircuitBreaker: Automatically fail fast when execution repeatedly fails

Fallback: Provide an alternative solution when execution fails


mvn io.quarkus:quarkus-maven-plugin:1.13.7.Final:create \
    -DprojectGroupId=org.acme \
    -DprojectArtifactId=microprofile-fault-tolerance-quickstart \
    -DclassName="org.acme.microprofile.faulttolerance.CoffeeResource" \
    -Dpath="/coffee" \
    -Dextensions="resteasy,smallrye-fault-tolerance,resteasy-jackson"
cd microprofile-fault-tolerance-quickstart



Timemout:

    @GET
    @Path("/{id}/recommendations")
    @Timeout(250)
    @Fallback(fallbackMethod = "fallbackRecommendations")
    public List<Coffee> recommendations(@PathParam int id) {
        long started = System.currentTimeMillis();
        final long invocationNumber = counter.getAndIncrement();

        try {
            randomDelay();
            LOGGER.infof("CoffeeResource#recommendations() invocation #%d returning successfully", invocationNumber);
            return coffeeRepository.getRecommendations(id);
        } catch (InterruptedException e) {
            LOGGER.errorf("CoffeeResource#recommendations() invocation #%d timed out after %d ms",
                    invocationNumber, System.currentTimeMillis() - started);
            return null;
        }
    }

    private void randomDelay() throws InterruptedException {
        // introduce some artificial delay
        Thread.sleep(new Random().nextInt(500));
    }

   /**
     * A fallback method for recommendations.
     */
    public List<Coffee> fallbackRecommendations(int id) {
        LOGGER.info("Falling back to RecommendationResource#fallbackRecommendations()");
        // safe bet, return something that everybody likes
        return Collections.singletonList(coffeeRepository.getCoffeeById(1));
    }

/////////////////////////////////////////////////////////////////////////////////////////////
Retry: Attempt execution again if it fails

 To avoid fail fast, give chance to get life.

if service throws exception, we dont want to send error immediately, rather we try for some time.

     *
     * This method fails about 50% of time. However, in case of a failure, the method is automatically re-invoked again
     * (up to 4 times), thanks to the {@link Retry} annotation. That means that a user is rarely exposed to a
     * failure, since the probability of a failure occurring 4 times in row is fairly low.
     */
    @GET
    @Retry(maxRetries = 4, retryOn = RuntimeException.class)
    public List<Coffee> coffees() {
        final Long invocationNumber = counter.getAndIncrement();

        maybeFail(String.format("CoffeeResource#coffees() invocation #%d failed", invocationNumber));

        LOGGER.infof("CoffeeResource#coffees() invocation #%d returning successfully", invocationNumber);
        return coffeeRepository.getAllCoffees();
    }

private void maybeFail(String failureLogMessage) {
        // introduce some artificial failures
        if (new Random().nextFloat() < failRatio) {
            LOGGER.error(failureLogMessage);
            throw new RuntimeException("Resource failure.");
        }
    }

///////////////////////////////////////////////////////////////////////////////////////////
Bulkhead: 

   Limit concurrent execution so that failures in that area can’t overload the whole system

  //only 10 threads/ 10 concurrent users can access this api
    @GET
    @Path("/bulk")
    @Bulkhead(value = 10)
    public Response dontOverload() {
        return Response.ok("bulk").build();
    }
///////////////////////////////////////////////////////////////////////////////////////////

CircuitBreaker: 
   Automatically fail fast when execution repeatedly fails

states
-open  - if something went wrong, cb starts fails fast
-half open - trying to recorver from open and closed
-closed - application running fine.


 App running--got error------open---|trips--- half open----closed or open

@Path("/{id}/availability")
    @GET
    public Response availability(@PathParam int id) {
        final Long invocationNumber = counter.getAndIncrement();

        Coffee coffee = coffeeRepository.getCoffeeById(id);

        // check that coffee with given id exists, return 404 if not
        if (coffee == null) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }

        try {
            Integer availability = coffeeRepository.getAvailability(coffee);
            LOGGER.infof("CoffeeResource#availability() invocation #%d returning successfully", invocationNumber);
            return Response.ok(availability).build();
        } catch (RuntimeException e) {
            String message = e.getClass().getSimpleName() + ": " + e.getMessage();
            LOGGER.errorf("CoffeeResource#availability() invocation #%d failed: %s", invocationNumber, message);
            return Response.status(Response.Status.INTERNAL_SERVER_ERROR)
                    .entity(message)
                    .build();
        }
    }
  @CircuitBreaker(requestVolumeThreshold = 4)
    public Integer getAvailability(Coffee coffee) {
        maybeFail();
        return availability.get(coffee.id);
    }

 private void maybeFail() {
        // introduce some artificial failures
        final Long invocationNumber = counter.getAndIncrement();
        if (invocationNumber % 4 > 1) { // alternate 2 successful and 2 failing invocations
            LOGGER.errorf("Invocation #%d failing", invocationNumber);
            throw new RuntimeException("Service failed.");
        }
        LOGGER.infof("Invocation #%d OK", invocationNumber);
    }
/////////////////////////////////////////////////////////////////////////////////////////////
3.Health :

Health checks are used to probe the state of a computing node from another machine (i.e. kubernetes service controller) with the primary target being cloud infrastructure environments where automated processes maintain the state of computing nodes.

In this scenario, health checks are used to determine if a computing node needs to be discarded (terminated, shutdown) and eventually replaced by another (healthy) instance.

It’s not intended (although could be used) as a monitoring solution for human operators.


@FunctionalInterface
public interface HealthCheck {

    HealthCheckResponse call();
}

QUARKUS - SMALLRYE HEALTH

/q/health/live - The application is up and running.

/q/health/ready - The application is ready to serve requests.

/q/health - Accumulating all health check procedures in the application.

public class HealthCheckResponse {

    public enum Status { UP, DOWN }

    private final String name;

    private final Status status;

    private final Optional<Map<String, Object>> data;

    [...]
}

Readiness checks defined with @Readiness annotation

Liveness checks defined with @Liveness annotation

////////////////////////////////////////////////////////////////////////////////////////////

MicroProfile OpenTracing:

  The MicroProfile OpenTracing specification defines behaviors and an API for accessing an OpenTracing compliant Tracer object within your JAX-RS application. The behaviors specify how incoming and outgoing requests will have OpenTracing Spans automatically created. The API defines how to explicitly disable or enable tracing for given endpoints.


Micro Meter with Promothus
..............................................................................................







 



















